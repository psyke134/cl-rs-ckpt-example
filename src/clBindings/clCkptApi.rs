pub use crate::clBindings::clCommon::*;
pub use crate::clBindings::clIocApi::*;
/* automatically generated by rust-bindgen 0.66.1 */

pub const CL_CKPT_WR_ALL_REPLICAS: u32 = 1;
pub const CL_CKPT_WR_ACTIVE_REPLICA: u32 = 2;
pub const CL_CKPT_WR_ACTIVE_REPLICA_WEAK: u32 = 4;
pub const CL_CKPT_CHECKPOINT_COLLOCATED: u32 = 8;
pub const CL_CKPT_DISTRIBUTED: u32 = 16;
pub const CL_CKPT_WR_ALL_SAFE: u32 = 32;
pub const CL_CKPT_ALL_OPEN_ARE_REPLICAS: u32 = 64;
pub const CL_CKPT_PEER_TO_PEER_REPLICA: u32 = 128;
pub const CL_CKPT_PEER_TO_PEER_CACHE_DISABLE: u32 = 256;
pub const CL_CKPT_CHECKPOINT_READ: u32 = 1;
pub const CL_CKPT_CHECKPOINT_WRITE: u32 = 2;
pub const CL_CKPT_CHECKPOINT_CREATE: u32 = 4;
#[doc = " The type of the handle for the the checkpoint service library."]
pub type ClCkptSvcHdlT = ClHandleT;
#[doc = "  The handle used to identify a checkpoint."]
pub type ClCkptHdlT = ClHandleT;
#[doc = " The handle used to identify a section in a checkpoint."]
pub type ClCkptSecItrHdlT = ClHandleT;
#[doc = "  Flags to indicate various attributes of a checkpoint on creation."]
pub type ClCkptCreationFlagsT = ClUint32T;
#[doc = "  Flags to indicate open mode such as read, write or create."]
pub type ClCkptOpenFlagsT = ClUint32T;
#[doc = "  Selection object."]
pub type ClCkptSelectionObjT = ClUint32T;
#[doc = "  This structure represents the properties of checkpoint that can be specified during the creation process."]
#[repr(C)]
pub struct ClCkptCheckpointCreationAttributesT {
    #[doc = "  Create time attributes."]
    pub creationFlags: ClCkptCreationFlagsT,
    #[doc = "  Total size of application data in a replica."]
    pub checkpointSize: ClSizeT,
    #[doc = "  Checkpoint which is inactive (not opened anywhere) for this duration (in nanoseconds) is deleted."]
    pub retentionDuration: ClTimeT,
    #[doc = "  Maximum sections for this checkpoint."]
    pub maxSections: ClUint32T,
    #[doc = " Maximum size of a section."]
    pub maxSectionSize: ClSizeT,
    #[doc = "  Maximum length of the section identifier."]
    pub maxSectionIdSize: ClSizeT,
}
#[test]
fn bindgen_test_layout_ClCkptCheckpointCreationAttributesT() {
    const UNINIT: ::std::mem::MaybeUninit<ClCkptCheckpointCreationAttributesT> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClCkptCheckpointCreationAttributesT>(),
        48usize,
        concat!("Size of: ", stringify!(ClCkptCheckpointCreationAttributesT))
    );
    assert_eq!(
        ::std::mem::align_of::<ClCkptCheckpointCreationAttributesT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ClCkptCheckpointCreationAttributesT)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).creationFlags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCkptCheckpointCreationAttributesT),
            "::",
            stringify!(creationFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).checkpointSize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCkptCheckpointCreationAttributesT),
            "::",
            stringify!(checkpointSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).retentionDuration) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCkptCheckpointCreationAttributesT),
            "::",
            stringify!(retentionDuration)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxSections) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCkptCheckpointCreationAttributesT),
            "::",
            stringify!(maxSections)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxSectionSize) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCkptCheckpointCreationAttributesT),
            "::",
            stringify!(maxSectionSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxSectionIdSize) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCkptCheckpointCreationAttributesT),
            "::",
            stringify!(maxSectionIdSize)
        )
    );
}
#[doc = "  This structure represents a section identifier."]
#[repr(C)]
pub struct ClCkptSectionIdT {
    #[doc = "  Length of the section identifier."]
    pub idLen: ClUint16T,
    #[doc = "  Section identifier."]
    pub id: *mut ClUint8T,
}
#[test]
fn bindgen_test_layout_ClCkptSectionIdT() {
    const UNINIT: ::std::mem::MaybeUninit<ClCkptSectionIdT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClCkptSectionIdT>(),
        16usize,
        concat!("Size of: ", stringify!(ClCkptSectionIdT))
    );
    assert_eq!(
        ::std::mem::align_of::<ClCkptSectionIdT>(),
        8usize,
        concat!("Alignment of ", stringify!(ClCkptSectionIdT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).idLen) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCkptSectionIdT),
            "::",
            stringify!(idLen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCkptSectionIdT),
            "::",
            stringify!(id)
        )
    );
}
#[doc = "  This structure represents section attributes that can be specified during the creation process."]
#[repr(C)]
pub struct ClCkptSectionCreationAttributesT {
    #[doc = "  Section identifier."]
    pub sectionId: *mut ClCkptSectionIdT,
    #[doc = " Section expiration time."]
    pub expirationTime: ClTimeT,
}
#[test]
fn bindgen_test_layout_ClCkptSectionCreationAttributesT() {
    const UNINIT: ::std::mem::MaybeUninit<ClCkptSectionCreationAttributesT> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClCkptSectionCreationAttributesT>(),
        16usize,
        concat!("Size of: ", stringify!(ClCkptSectionCreationAttributesT))
    );
    assert_eq!(
        ::std::mem::align_of::<ClCkptSectionCreationAttributesT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ClCkptSectionCreationAttributesT)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sectionId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCkptSectionCreationAttributesT),
            "::",
            stringify!(sectionId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).expirationTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCkptSectionCreationAttributesT),
            "::",
            stringify!(expirationTime)
        )
    );
}
#[doc = " Indicates that the section is fine."]
pub const ClCkptSectionStateT_CL_CKPT_SECTION_VALID: ClCkptSectionStateT = 1;
#[doc = "  Indicates that the section has been corrupted."]
pub const ClCkptSectionStateT_CL_CKPT_SECTION_CORRUPTED: ClCkptSectionStateT = 2;
#[doc = "  This enum represents the state of a section in a replica."]
pub type ClCkptSectionStateT = ::std::os::raw::c_uint;
#[doc = "  This structure represents a section in a checkpoint."]
#[repr(C)]
pub struct ClCkptSectionDescriptorT {
    #[doc = " Section identifier."]
    pub sectionId: ClCkptSectionIdT,
    #[doc = "  Expiration time for the section."]
    pub expirationTime: ClTimeT,
    #[doc = " Size of the section."]
    pub sectionSize: ClSizeT,
    #[doc = " Indicates whether a section has a valid or an invalid state."]
    pub sectionState: ClCkptSectionStateT,
    #[doc = "  Last time the section is updated."]
    pub lastUpdate: ClTimeT,
}
#[test]
fn bindgen_test_layout_ClCkptSectionDescriptorT() {
    const UNINIT: ::std::mem::MaybeUninit<ClCkptSectionDescriptorT> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClCkptSectionDescriptorT>(),
        48usize,
        concat!("Size of: ", stringify!(ClCkptSectionDescriptorT))
    );
    assert_eq!(
        ::std::mem::align_of::<ClCkptSectionDescriptorT>(),
        8usize,
        concat!("Alignment of ", stringify!(ClCkptSectionDescriptorT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sectionId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCkptSectionDescriptorT),
            "::",
            stringify!(sectionId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).expirationTime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCkptSectionDescriptorT),
            "::",
            stringify!(expirationTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sectionSize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCkptSectionDescriptorT),
            "::",
            stringify!(sectionSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sectionState) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCkptSectionDescriptorT),
            "::",
            stringify!(sectionState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lastUpdate) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCkptSectionDescriptorT),
            "::",
            stringify!(lastUpdate)
        )
    );
}
#[doc = " All sections with expiration time set to CL_TIME_END"]
pub const ClCkptSectionsChosenT_CL_CKPT_SECTIONS_FOREVER: ClCkptSectionsChosenT = 1;
#[doc = " All sections with expiration time less than or equal to the value\n of expirationTime."]
pub const ClCkptSectionsChosenT_CL_CKPT_SECTIONS_LEQ_EXPIRATION_TIME: ClCkptSectionsChosenT = 2;
#[doc = " All sections with expiration time greater than or equal to the value\n of expiration time"]
pub const ClCkptSectionsChosenT_CL_CKPT_SECTIONS_GEQ_EXPIRATION_TIME: ClCkptSectionsChosenT = 3;
#[doc = " All corrupted sections."]
pub const ClCkptSectionsChosenT_CL_CKPT_SECTIONS_CORRUPTED: ClCkptSectionsChosenT = 4;
#[doc = " All sections"]
pub const ClCkptSectionsChosenT_CL_CKPT_SECTIONS_ANY: ClCkptSectionsChosenT = 5;
#[doc = " This enum is used for selection of sections while iterating through all the sections."]
pub type ClCkptSectionsChosenT = ::std::os::raw::c_uint;
#[doc = " This structure represents an IO vector which will be used for dealing with more than zero sections."]
#[repr(C)]
pub struct ClCkptIOVectorElementT {
    #[doc = "  Identifier of the section."]
    pub sectionId: ClCkptSectionIdT,
    #[doc = "  Pointer to the data."]
    pub dataBuffer: ClPtrT,
    #[doc = " Size of the data."]
    pub dataSize: ClSizeT,
    #[doc = "  Offset."]
    pub dataOffset: ClOffsetT,
    #[doc = "  Number of bytes read."]
    pub readSize: ClSizeT,
}
#[test]
fn bindgen_test_layout_ClCkptIOVectorElementT() {
    const UNINIT: ::std::mem::MaybeUninit<ClCkptIOVectorElementT> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClCkptIOVectorElementT>(),
        48usize,
        concat!("Size of: ", stringify!(ClCkptIOVectorElementT))
    );
    assert_eq!(
        ::std::mem::align_of::<ClCkptIOVectorElementT>(),
        8usize,
        concat!("Alignment of ", stringify!(ClCkptIOVectorElementT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sectionId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCkptIOVectorElementT),
            "::",
            stringify!(sectionId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataBuffer) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCkptIOVectorElementT),
            "::",
            stringify!(dataBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataSize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCkptIOVectorElementT),
            "::",
            stringify!(dataSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataOffset) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCkptIOVectorElementT),
            "::",
            stringify!(dataOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).readSize) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCkptIOVectorElementT),
            "::",
            stringify!(readSize)
        )
    );
}
#[doc = "  This structure is used to describe a checkpoint."]
#[repr(C)]
pub struct ClCkptCheckpointDescriptorT {
    #[doc = "  Creates attribute."]
    pub checkpointCreationAttributes: ClCkptCheckpointCreationAttributesT,
    #[doc = "  Total number of sections."]
    pub numberOfSections: ClUint32T,
    #[doc = "  Memory used by the checkpoint."]
    pub memoryUsed: ClUint32T,
}
#[test]
fn bindgen_test_layout_ClCkptCheckpointDescriptorT() {
    const UNINIT: ::std::mem::MaybeUninit<ClCkptCheckpointDescriptorT> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClCkptCheckpointDescriptorT>(),
        56usize,
        concat!("Size of: ", stringify!(ClCkptCheckpointDescriptorT))
    );
    assert_eq!(
        ::std::mem::align_of::<ClCkptCheckpointDescriptorT>(),
        8usize,
        concat!("Alignment of ", stringify!(ClCkptCheckpointDescriptorT))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).checkpointCreationAttributes) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCkptCheckpointDescriptorT),
            "::",
            stringify!(checkpointCreationAttributes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numberOfSections) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCkptCheckpointDescriptorT),
            "::",
            stringify!(numberOfSections)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memoryUsed) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCkptCheckpointDescriptorT),
            "::",
            stringify!(memoryUsed)
        )
    );
}
#[doc = "  \\brief This function gets called whenever a checkpoint is getting updated\n   on the local server. Provided the application has been registered for the\n   checkpoint update.\n\n  \\par Header File:\n  clCkptApi.h\n\n  \\param ckptHdl (in) Handle of the updated checkpoint.\n\n  \\param pName (in) Name of the checkpoint has been updated locally.\n\n  \\param pIoVector (in) List of updated sections and data of the checkpoint.\n\n  \\param numSections (in) Number of sections are being updated on this checkpoint.\n\n  \\param pCookie (in) Cookie which got from clCkptImmediateConsumptionRegister will be given back to\n                      application via this variable.\n\n  \\retval  CL_OK The Log stream is opened successfully.\n\n  \\retval  CL_ERR_TIMEOUT An implementation defined timeout occurred before the call\n  could complete.\n\n  \\retval  CL_ERR_NO_MEMORY Either the Ckpt Service library or some other module of\n  Ckpt Service is out of memory. Thus service can not be provided at this time. This\n  may be a transient problem.\n\n  \\par Description:\n  This notification callback is getting called, whenever the particular\n  checkpoint has been updated on the local server.This callback will be called\n  for whoever registers for the checkpoint update. Thie notication callback will be\n  registered through clCkptImmediateConsumptionRegister() call. This function carries\n  information about all updated sections and number of sections. This is mainly used\n  for HOT stanby applications on which the stanby application will be notified\n  immediately.\n\n  \\par Library File:\n  ClCkpt\n\n  \\sa clCkptImmediateConsumptionRegister\n"]
pub type ClCkptNotificationCallbackT = ::std::option::Option<
    unsafe extern "C" fn(
        ckptHdl: ClCkptHdlT,
        pName: *mut ClNameT,
        pIOVector: *mut ClCkptIOVectorElementT,
        numSections: ClUint32T,
        pCookie: ClPtrT,
    ) -> ClRcT,
>;
#[doc = "  \\brief This function gets called When clCkptCheckpointOpenAsync() call\n   returns on the server.\n\n  \\par Header File:\n  clCkptApi.h\n\n  \\param invocation (in) invocation value of the call. This is basically an\n  identification about the call.\n\n  \\param checkpointHandle (in) contains handle of the opened checkpoint, if the\n  clCkptCheckpointOpenAsync() was succesfull.\n\n  \\param error (in) return value of the clCkptCheckpointOpenAsync() call\n\n  \\retval  CL_OK The checkpoint is opened successfully.\n\n  \\retval  CL_ERR_NOT_EXIST \\c CL_CKPT_CHECKPOINT_CREATE flag is not set in creation flags and\n  the checkpoint does not exist.\n\n  \\retval CL_ERR_ALREADY_EXIST \\c CL_CKPT_CHECKPOINT_CREATE flag is set in creation flags but\n  the Checkpoint already exists and was originally created with different\n  attributes than specified by CheckpointCreation attributes.\n\n  \\retval  CL_ERR_TIMEOUT An implementation defined timeout occurred before the call\n  could complete.\n\n  \\retval  CL_ERR_TRY_AGAIN The service could not be provided at this time.\n  The process may try later.\n\n  \\retval  CL_ERR_NO_MEMORY Either the Checkpoint Service library or some other module of\n  Ckpt Service is out of memory. Thus service can not be provided at this time. This\n  may be a transient problem.\n\n  \\retval  CL_ERR_NO_RESOURCE Either the Checkpoint Service library or some other module\n  of Checkpoint Service is out of resources (other than memory). Thus, service can not be\n  provided at this time. This may be a transient problem.\n\n  \\par Description:\n  This CheckpointOpe callback function is getting called, when\n  clCkptCheckpointOpenAsync() call returns from the server. It carries the\n  invocation to identify the call and return code for indicating the status\n  of the call. If the retcode is CL_OK, then checkpoint handlE will be carrying\n  the proper handle of the checkpoint which was opened on the particular\n  invocation.\n\n  \\par Library File:\n  ClCkpt\n\n  \\sa clCkptCheckpointOpenAsync()\n"]
pub type ClCkptCheckpointOpenCallbackT = ::std::option::Option<
    unsafe extern "C" fn(invocation: ClInvocationT, checkpointHandle: ClCkptHdlT, error: ClRcT),
>;
#[doc = "  \\brief This function gets called When clCkptCheckpointSynchronizeAsync() call\n   returns on the server.\n\n  \\par Header File:\n  clCkptApi.h\n\n  \\param invocation (in) invocation value of the call. This is basically an\n  identification about the call.\n\n  \\param error (in) return value of the clCkptCheckpointSynchronizeAsync() call\n\n  \\retval  CL_OK The checkpoint is opened successfully.\n\n  \\retval  CL_ERR_TIMEOUT An implementation defined timeout occurred before the call\n  could complete.\n\n  \\retval  CL_ERR_TRY_AGAIN The service could not be provided at this time.\n  The process may try later.\n\n  \\retval  CL_ERR_NO_MEMORY Either the Checkpoint Service library or some other module of\n  Ckpt Service is out of memory. Thus service can not be provided at this time. This\n  may be a transient problem.\n\n  \\retval  CL_ERR_NO_RESOURCE Either the Checkpoint Service library or some other module\n  of Checkpoint Service is out of resources (other than memory). Thus, service can not be\n  provided at this time. This may be a transient problem.\n\n  \\par Description:\n  Applications which use asynchronous checkpoint option will be notified about the asynchronous\n  write or open status with a callback. If any problem occurs with the asynchronous write,\n  the application asks checkpointing to synchronize all the replicas. This is an\n  asynchronous call. So the applications can register another optional callback which will enable\n  them to know the status of 'synchronize-all-replicas' call.\n\n  \\par Library File:\n  ClCkpt\n\n  \\sa clCkptCheckpointSynchronizeAsync()\n"]
pub type ClCkptCheckpointSynchronizeCallbackT =
    ::std::option::Option<unsafe extern "C" fn(invocation: ClInvocationT, error: ClRcT)>;
#[doc = "  This structure is the only location where all the callbacks converge."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ClCkptCallbacksT {
    #[doc = "  Asynchronous open callback."]
    pub checkpointOpenCallback: ClCkptCheckpointOpenCallbackT,
    #[doc = " Synchronize callback."]
    pub checkpointSynchronizeCallback: ClCkptCheckpointSynchronizeCallbackT,
}
#[test]
fn bindgen_test_layout_ClCkptCallbacksT() {
    const UNINIT: ::std::mem::MaybeUninit<ClCkptCallbacksT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClCkptCallbacksT>(),
        16usize,
        concat!("Size of: ", stringify!(ClCkptCallbacksT))
    );
    assert_eq!(
        ::std::mem::align_of::<ClCkptCallbacksT>(),
        8usize,
        concat!("Alignment of ", stringify!(ClCkptCallbacksT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).checkpointOpenCallback) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCkptCallbacksT),
            "::",
            stringify!(checkpointOpenCallback)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).checkpointSynchronizeCallback) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCkptCallbacksT),
            "::",
            stringify!(checkpointSynchronizeCallback)
        )
    );
}
extern "C" {
    #[doc = "  \\brief  Initializes the checkpoint service client and registers the various callbacks.\n\n  \\par Header File:\n  clCkptApi.h\n\n  \\param ckptSvcHandle (out) Checkpoint service handle created by the checkpoint client\n  and returned to the application. This handle designates this particular initialization of the\n  the Checkpoint Service. The application must not modify or interpret this.\n\n  \\param callbacks Optional callbacks for applications which use asynchronous checkpoints.\n\n  \\param version (in/out)  As an input parameter, version is a pointer to the required\n  Checkpoint Service version.  As an output parameter, the version actually supported by the\n  Checkpoint Service is delivered.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_TRY_AGAIN System is in a transitory unstable state, please try later.\n  \\retval CL_ERR_NULL_POINTER\n  \\retval CL_ERR_VERSION_MISMATCH\n\n  \\par Description:\n  This function initializes the Checkpoint library for the invoking process and registers\n  the various callback functions. This function must be invoked prior to the invocation of\n  any other Checkpoint Service functionality. The handle \\e ckptSvcHandle is returned as the\n  reference to this association between the process and the Checkpoint Service. The\n  process uses this handle in subsequent communication with the Checkpoint Service.\n\nx\n  \\par Library File:\n  ClCkpt\n\n  \\sa clCkptFinalize()\n"]
    pub fn clCkptInitialize(
        ckptSvcHandle: *mut ClCkptSvcHdlT,
        callbacks: *const ClCkptCallbacksT,
        version: *mut ClVersionT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief  Closes the checkpoint service client and cancels all pending callbacks related to the handle.\n\n  \\par Header File:\n  clCkptApi.h\n\n  \\param ckptHandle The handle, obtained through the clCkptInitialize() function,\n   designating this particular initialization of the Checkpoint Service.\n\n  \\retval CL_OK The API executed successfully.\n\n  \\par Description:\n  The clCkptFinalize() function closes the association, represented by the \\e ckptHandle\n  parameter, between the invoking process and the Checkpoint Service. The process\n  must have invoked clCkptInitialize() before it invokes this function. A process must\n  invoke this function once for each handle acquired by invoking  clCkptInitialize().\n\n  \\par\n  If the clCkptFinalize() function returns successfully, the clCkptFinalize() function\n  releases all resources acquired when clCkptInitialize() was called. Moreover, it\n  closes all checkpoints that are open for the particular handle. Furthermore, it cancels\n  all pending callbacks related to the particular handle.\n\n  \\par\n  After clCkptFinalize() is called, the selection object is no longer valid. Note that\n  because the callback invocation is asynchronous, it is still possible that some callback\n  calls are processed after this call returns successfully.\n\n  \\par Library File:\n  ClCkpt\n\n  \\sa clCkptInitialize()\n"]
    pub fn clCkptFinalize(ckptHandle: ClCkptSvcHdlT) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Opens an existing checkpoint. If there is no existing checkpoint,\n   then this function creates a new checkpoint and opens it.\n\n  \\par Header File:\n  clCkptApi.h\n\n  \\param ckptHandle The handle, obtained through the clCkptInitialize() function,\n   designating this particular initialization of the Checkpoint Service.\n\n  \\param ckeckpointName Name of the checkpoint to be opened.\n\n  \\param  checkpointCreationAttributes A pointer to the create attributes of a the checkpoint.\n  Refer to ClCkptCheckpointCreationAttributesT structure. This parameter must be filled\n  only when the \\c CREATE flag is set.\n\n  \\param checkpointOpenFlags  Flags to indicate the desired mode to open. It can have the following values:\n  \\arg \\c CL_CKPT_CHECKPOINT_READ\n  \\arg \\c CL_CKPT_CHECKPOINT_WRITE\n  \\arg \\c CL_CKPT_CHECKPOINT_CREATE\n\n  \\param timeout clCkptCheckpointOpen is considered to be failed if not completed within the timeout.\n  A checkpoint replica may still be created. [It is not supported currently]\n\n  \\param checkpointHandle (out) A pointer to the checkpoint handle, allocated in the address\n  space of the invoking process. If the checkpoint is opened successfully, the Checkpoint\n  Service stores in \\e checkpointHandle the handle that the process uses to access\n  the checkpoint in subsequent invocations of the functions of the Checkpoint Service.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER  When the parameters passed are NULL pointers.\n  \\retval CL_ERR_NOT_INITIALIZED If the checkpoint server is not completely initialized.\n  \\retval CL_ERR_ALREADY_EXIST If the checkpoint is already existing.\n  \\retval CL_ERR_NO_MEMORY If there is not enough memory.\n  \\retval CL_ERR_TRY_AGAIN System is in a transitory unstable state, please try later.\n\n  \\par Description:\n  The clCkptCheckpointOpen() function opens a checkpoint.\n  If the checkpoint does not exist, the checkpoint is created first.\n  An invocation of clCkptCheckpointOpen() is blocking. A new checkpoint handle is\n  returned upon completion. A checkpoint can be opened multiple times for reading\n  and/or writing in the same process or in different processes.\n\n  \\par\n  When a checkpoint is opened using the clCkptCheckpointOpen() or\n  clCkptCheckpointOpenAsync() function, some combination of the creation flags,\n  defined in ClCkptCheckpointCreationFlagsT, are bitwise OR-ed together to provide\n  the value of the \\e creationFlags field of the \\e checkpointCreationAttributes parameter.\n\n  \\par Library File:\n  ClCkpt\n\n  \\sa clCkptCheckpointOpenAsync(), clCkptCheckpointClose()\n"]
    pub fn clCkptCheckpointOpen(
        ckptHandle: ClCkptSvcHdlT,
        ckeckpointName: *const ClNameT,
        checkpointCreationAttributes: *const ClCkptCheckpointCreationAttributesT,
        checkpointOpenFlags: ClCkptOpenFlagsT,
        timeout: ClTimeT,
        checkpointHandle: *mut ClCkptHdlT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Creates and opens a checkpoint asynchronously.\n\n  \\par Header File:\n  clCkptApi.h\n\n  \\param ckptHandle The handle, obtained through the clCkptInitialize() function,\n   designating this particular initialization of the Checkpoint Service.\n\n  \\param invocation This parameter is used by the application to identify the callback.\n\n  \\param checkpointName Name of the checkpoint to be opened.\n\n  \\param checkpointCreationAttributes Pointer to the create attributes of a the checkpoint.\n  Refer to ClCkptCheckpointCreationAttributesT structure.\n\n  \\param checkpointOpenFlags  Flags to indicate the desired mode to open. It can have the following values:\n  \\arg \\c CL_CKPT_CHECKPOINT_READ\n  \\arg \\c CL_CKPT_CHECKPOINT_WRITE\n  \\arg \\c CL_CKPT_CHECKPOINT_CREATE\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_TRY_AGAIN System is in a transitory unstable state, please try later.\n\n  \\par Description:\n  This function is used to create and open a checkpoint asynchronously.\n\n\n  \\par Library File:\n  ClCkpt\n\n  \\sa clCkptCheckpointOpen(), clCkptCheckpointClose()"]
    pub fn clCkptCheckpointOpenAsync(
        ckptHandle: ClCkptSvcHdlT,
        invocation: ClInvocationT,
        checkpointName: *const ClNameT,
        checkpoiNtCreationAttributes: *const ClCkptCheckpointCreationAttributesT,
        checkpointOpenFlags: ClCkptOpenFlagsT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Closes the checkpoint designated by the \\e checkpointHandle.\n\n  \\par Header File:\n  clCkptApi.h\n\n  \\param checkpointHandle The handle \\e checkpointHandle must have been obtained\n   previously by the invocation of the clCkptCheckpointOpen() function.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NOT_INITIALIZED If the checkpoint server is not completely initialized.\n  \\retval CL_ERR_NO_MEMORY On memory allocation failure.\n\n  \\par Description:\n  This function closes the checkpoint, designated by \\e checkpointHandle, which was\n  opened by an earlier invocation of the clCkptCheckpointOpen() or\n  clCkptCheckpointOpenAsync() function.\n\n  \\par\n  After this invocation, the handle \\e checkpointHandle is no longer valid.\n  The deletion of a checkpoint frees all resources allocated by the Checkpoint Service\n  for it. When a process is terminated, all of its opened checkpoints are closed.\n  This call cancels all pending callbacks that refer directly or indirectly to the handle\n  \\e checkpointHandle.\n\n  \\par\n  In case  clCkptCheckpointDelete() has already been called, then by calling the clCkptCheckpointClose()\n  function, the reference count to this checkpoint becomes zero and the checkpoint is deleted.\n  After this call, if the reference count becomes 0, and clCkptCheckpointDelete() has not been called,\n  then the retention timer associated with the checkpoint [ and provided during invocation of\n  clCkptCheckpointOpenAsync() or clCkptCheckpointOpen() functions ] is started. On expiration of the timer\n  the checkpoint is deleted.\n\n  \\par Library File:\n  ClCkpt\n\n  \\sa clCkptCheckpointOpen(), clCkptCheckpointOpenAsync(), clCkptCheckpointDelete()\n"]
    pub fn clCkptCheckpointClose(checkpointHandle: ClCkptHdlT) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Removes the checkpoint from the system and frees all resources allocated to it.\n\n  \\par Header File:\n  clCkptApi.ht\n\n  \\param ckptHandle The handle, obtained through the clCkptInitialize() function,\n   designating this particular initialization of the Checkpoint Service.\n  \\param checkpointName Pointer to the name of the checkpoint to be deleted.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER  If the parameters passed are NULL pointers.\n  \\retval CL_ERR_NOT_INITIALIZED If the checkpoint server is not completely initialized.\n  \\retval CL_ERR_NO_MEMORY On memory allocation failure.\n  \\retval CL_ERR_INUSE If the checkpoint is already in use.\n\n  \\par Description:\n  This function deletes an existing checkpoint, identified by \\e checkpointName from the\n  cluster.\n\n  \\par\n  After completion of the invocation,\n  \\arg The name \\e checkpointName is no longer valid, that is, any invocation of a function\n  of the Checkpoint Service that uses the checkpoint name returns an error,\n  unless a checkpoint is re-created with this name. The checkpoint is re-created\n  by specifying the same name of the checkpoint to be unlinked in an open call\n  with the \\c CL_CKPT_CHECKPOINT_CREATE flag set. This way, a new instance\n  of the checkpoint is created, while the old instance of the checkpoint is\n  not yet finally deleted. Note that this is similar to the way POSIX treats files.\n  \\arg If no process has the checkpoint open when clCkptCheckpointDelete() is\n  invoked, the checkpoint is immediately deleted.\n  \\arg Any process that has the checkpoint open can still continue to access it. Deletion\n  of the checkpoint will occur when the last clCkptCheckpointClose() operation is\n  performed.\n\n  \\par\n  The deletion of a checkpoint frees all resources allocated by the Checkpoint Service\n  for it. This function can be invoked by any process, and the invoking process need not be the\n  creator or opener of the checkpoint.\n\n  \\par Library File:\n  ClCkpt\n\n  \\sa clCkptCheckpointOpen(), clCkptCheckpointOpenAsync(), clCkptCheckpointClose()\n"]
    pub fn clCkptCheckpointDelete(
        ckptHandle: ClCkptSvcHdlT,
        checkpointName: *const ClNameT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Sets the retention duration of a checkpoint.\n\n  \\par Header File:\n  clCkptApi.h\n\n  \\param checkpointHandle The checkpoint whose retention time is being set. This handle\n  is obtained by invoking clCkptCheckpointOpen() function.\n  \\param retentionDuration Duration for which the checkpoint can be retained in nanoseconds.\n\n  \\retval CL_OK The API executed successfully.\n\n  \\par Description:\n  This function is used to set the retention duration of a checkpoint.\n  If by invocation of clCkptCheckpointClose(), the reference count becomes 0, and clCkptCheckpointDelete() has not been\n  called, then the retention timer associated with the checkpoint ( and provided during invocation of\n  clCkptCheckpointOpenAsync() or clCkptCheckpointOpen() functions ) is started. On expiration of the timer, the checkpoint\n  is deleted.\n\n  \\par Library File:\n  ClCkpt\n"]
    pub fn clCkptCheckpointRetentionDurationSet(
        checkpointHandle: ClCkptHdlT,
        retentionDuration: ClTimeT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Sets the local replica to be active replica.\n\n  \\par Header File:\n  clCkptApi.h\n\n  \\param checkpointHandle The handle \\e checkpointHandle obtained by invoking\n   clCkptCheckpointOpen() function.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_TRY_AGAIN System is in a transitory unstable state, please try later.\n\n  \\par Description:\n  This function is used to set the local replica to be active replica\n  if no active replica has been set for the checkpoint.\n\n  \\par Library File:\n  ClCkpt\n"]
    pub fn clCkptActiveReplicaSet(checkpointHandle: ClCkptHdlT) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief  Returns the status and the various attributes of the checkpoint.\n\n  \\par Header File:\n  clCkptApi.ht\n\n  \\param checkpointHandle  The handle of the checkpoint obtained by invoking\n   clCkptCheckpointOpen() function.\n  \\param checkpointStatus (out) Pointer to checkpoint descriptor in the address space of\n   the invoking process, that contains the checkpoint status information to be returned.\n   Refer to ClCkptCheckpointDescriptorT structure.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER  If the \\e checkpointStatus parameter passed is a NULL pointer.\n  \\retval CL_ERR_NOT_INITIALIZED If the checkpoint server is not completely initialized.\n  \\retval CL_ERR_NO_MEMORY On memory allocation failure.\n  \\retval CL_ERR_TRY_AGAIN System is in a transitory unstable state, please try later.\n\n  \\par Description:\n  This function is used to return the status and the various attributes of the checkpoint.\n  The list of attributes are defined by the ClCkptCheckpointDescriptorT structure.\n  This function retrieves the \\e checkpointStatus of the checkpoint designated by\n  checkpointHandle.\n\n  \\par\n  If the checkpoint was created using either \\c CL_CKPT_WR_ACTIVE_REPLICA or\n  \\c CL_CKPT_WR_ACTIVE_REPLICA_WEAK option, the checkpoint status is obtained\n  from the active replica. If the checkpoint was created using the\n  \\c CL_CKPT_WR_ALL_REPLICAS option, the Checkpoint Service determines the replica\n  from which to obtain the checkpoint status.\n\n  \\par Library File:\n  ClCkpt\n"]
    pub fn clCkptCheckpointStatusGet(
        checkpointHandle: ClCkptHdlT,
        checkpointStatus: *mut ClCkptCheckpointDescriptorT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Creates a section in the checkpoint.\n\n  \\par Header File:\n  clCkptApi.h\n\n  \\param checkpointHandle The handle \\e checkpointHandle obtained by invoking\n   clCkptCheckpointOpen() function.\n\n  \\param sectionCreationAttributes A pointer to a ClCkptSectionCreationAttributesT\n  structure, that contains the (in/out) field \\e sectionId and the (in) field \\e expirationTime.\n\n  \\param initialData Pointer to the location in the address space of the invoking\n  process that contains the initial data of the section to be created.\n\n  \\param initialDataSize The size in bytes of the initial data of the section to be created.\n  Initial size can be at most \\e maxSectionSize, as specified by the checkpoint creation\n  attributes in clCkptCheckpointOpen().\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER  When either of the parameters \\e sectionCreationAttributes\n  or initialData passed are NULL pointers.\n  \\retval CL_ERR_NOT_INITIALIZED If the checkpoint server is not completely initialized.\n  \\retval CL_ERR_ALREADY_EXIST If the checkpoint is already existing.\n  \\retval CL_ERR_NO_MEMORY On memory allocation failure.\n  \\retval CL_ERR_TRY_AGAIN System is in a transitory unstable state, please try later.\n\n  \\par Description:\n  This function creates a new section in the checkpoint referred to by checkpointHandle\n  as long as the total number of existing sections is less than the maximum number of\n  sections specified by the clCkptCheckpointOpen() or\n  clCkptCheckpointOpenAsync() function call. Unlike a checkpoint, a section\n  need not be opened for access. The section will be deleted by the Checkpoint Service\n  when its expiration time is reached.\n  \\par\n  If a checkpoint is created to have only one section,\n  it is not necessary to create that section. The default section is identified by the\n  special identifier \\c CL_CKPT_DEFAULT_SECTION_ID. If the checkpoint was created\n  with the \\c CL_CKPT_WR_ALL_REPLICAS property, the section is created in all of the\n  checkpoint replicas when the invocation returns; otherwise, the section has been created\n  at least in the active checkpoint replica, when the invocation returns and will be\n  created asynchronously in the other checkpoint replicas.\n\n  \\par Library File:\n  ClCkpt\n\n  \\sa\n  clCkptSectionDelete(),\n  clCkptSectionExpirationTimeSet(),\n  clCkptSectionIterationInitialize(),\n  clCkptSectionIterationNext(),\n  clCkptSectionIterationFinalize(),\n  clCkptCheckpointWrite(),\n  clCkptSectionOverwrite()\n"]
    pub fn clCkptSectionCreate(
        checkpointHandle: ClCkptHdlT,
        sectionCreationAttributes: *mut ClCkptSectionCreationAttributesT,
        initialData: *const ClUint8T,
        initialDataSize: ClSizeT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief  Deletes a section in the given checkpoint.\n\n  \\par Header File:\n  clCkptApi.ht\n\n  \\param checkpointHandle  The handle to the checkpoint holding the section\n   to be deleted. The handle to the checkpoint holding the section to\n   be deleted. The handle \\e checkpointHandle obtained by invoking\n   clCkptCheckpointOpen() function.\n  \\param sectionId A pointer to the identifier of the section to be deleted.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER  When the parameter \\e sectionId passed is a NULL pointer.\n  \\retval CL_ERR_NOT_INITIALIZED If the checkpoint server is not completely initialized.\n  \\retval CL_ERR_NO_MEMORY On memory allocation failure.\n  \\retval CL_ERR_TRY_AGAIN System is in a transitory unstable state, please try later.\n\n  \\par Description:\n  This function deletes a section in the checkpoint referred to by \\e checkpointHandle. If\n  the checkpoint was created with the \\c CL_CKPT_WR_ALL_REPLICAS property, the\n  section has been deleted in all of the checkpoint replicas when the invocation returns;\n  otherwise, the section has been deleted at least in the active checkpoint replica when\n  the invocation returns. The default section, identified by\n  \\c CL_CKPT_DEFAULT_SECTION_ID, cannot be deleted by invoking the\n  clCkptSectionDelete() function.\n\n  \\par Library File:\n  ClCkpt\n\n  \\sa\n   clCkptSectionCreate(),\n   clCkptSectionExpirationTimeSet(),\n   clCkptSectionIterationInitialize(),\n   clCkptSectionIterationNext(),\n   clCkptSectionIterationFinalize(),\n   clCkptCheckpointWrite(),\n   clCkptSectionOverwrite()"]
    pub fn clCkptSectionDelete(
        checkpointHandle: ClCkptHdlT,
        sectionId: *const ClCkptSectionIdT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Sets the expiration time of a section.\n\n  \\par Header File:\n  clCkptApi.h\n\n  \\param checkpointHandle The handle \\e checkpointHandle obtained by invoking\n   clCkptCheckpointOpen() function.\n  \\param sectionId Section identifier.\n  \\param expirationTime Expiration time of the section.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_TRY_AGAIN System is in a transitory unstable state, please try later.\n\n  \\par Description:\n  This function is used to set the expiration time of a section.\n\n  \\par Library File:\n  ClCkpt\n\n  \\sa\n   clCkptSectionCreate(),\n   clCkptSectionDelete(),\n   clCkptSectionIterationInitialize(),\n   clCkptSectionIterationNext(),\n   clCkptSectionIterationFinalize(),\n   clCkptCheckpointWrite(),\n   clCkptSectionOverwrite()\n"]
    pub fn clCkptSectionExpirationTimeSet(
        checkpointHandle: ClCkptHdlT,
        sectionId: *const ClCkptSectionIdT,
        expirationTime: ClTimeT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Enables the application to iterate through sections in a checkpoint.\n\n  \\par Header File:\n  clCkptApi.h\n\n  \\param checkpointHandle  The handle \\e checkpointHandle obtained by invoking\n   clCkptCheckpointOpen() function.\n  \\param sectionsChosen Rule for the iteration.\n   Refer the ClCkptSectionChosenT enum.\n  \\param expirationTime Expiration time used along with the rule.\n  \\param sectionIterationHandle (out) Handle used to identify a present section.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_TRY_AGAIN System is in a transitory unstable state, please try later.\n\n  \\par Description:\n   This function is used to enable the application to iterate through the sections in a checkpoint.\n\n\n  \\par Library File:\n  ClCkpt\n\n  \\sa\n  clCkptSectionCreate(),\n  clCkptSectionDelete(),\n  clCkptSectionExpirationTimeSet(),\n  clCkptSectionIterationNext(),\n  clCkptSectionIterationFinalize(),\n  clCkptCheckpointWrite(),\n  clCkptSectionOverwrite()\n"]
    pub fn clCkptSectionIterationInitialize(
        checkpointHandle: ClCkptHdlT,
        sectionsChosen: ClCkptSectionsChosenT,
        expirationTime: ClTimeT,
        sectionIterationHandle: *mut ClHandleT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief  Returns the next section in the list of sections.\n\n  \\par Header File:\n  clCkptApi.h\n\n  \\param sectionIterationHandle Checkpoint handle returned as part of clCkptCheckpointOpen().\n  \\param sectionDescriptor (out) Pointer to the descriptor of a section.\n   Refer the ClCkptSectionDescriptorT structure.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_TRY_AGAIN System is in a transitory unstable state, please try later.\n\n  \\par Description:\n  This function is used to retrieve the next section in the list of sections matching the\n  clCkptSectionIterationInitialize() call.\n\n  \\par Library File:\n  ClCkpt\n\n  \\sa\n  clCkptSectionCreate(),\n  clCkptSectionDelete(),\n  clCkptSectionExpirationTimeSet(),\n  clCkptSectionIterationInitialize(),\n  clCkptSectionIterationFinalize(),\n  clCkptCheckpointWrite(),\n  clCkptSectionOverwrite\n"]
    pub fn clCkptSectionIterationNext(
        sectionIterationHandle: ClHandleT,
        sectionDescriptor: *mut ClCkptSectionDescriptorT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Frees resources associated with the iteration.\n\n  \\par Header File:\n  clCkptApi.h\n\n  \\param sectionIterationHandle Handle of the iteration.\n\n  \\retval CL_OK The API executed successfully.\n\n  \\par Description:\n  This function is used to free resources associated with the iteration\n  identified by the sectionIterationHandle.\n\n  \\par Library File:\n  ClCkpt\n\n  \\sa\n  clCkptSectionCreate(),\n  clCkptSectionDelete(),\n  clCkptSectionExpirationTimeSet(),\n  clCkptSectionIterationInitialize(),\n  clCkptSectionIterationNext(),\n  clCkptCheckpointWrite(),\n  clCkptSectionOverwrite()\n"]
    pub fn clCkptSectionIterationFinalize(sectionIterationHandle: ClHandleT) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief  Writes multiple sections on to a given checkpoint.\n\n  \\par Header File:\n  clCkptApi.h\n\n  \\param checkpointHandle The handle to the checkpoint that is to be written to.\n  The handle \\e checkpointHandle obtained by invoking either\n  clCkptCheckpointOpen() or clCkptCheckpointOpenAsync() function.\n\n  \\param ioVector Pointer to the IO Vector containing the section IDs and the data to be written.\n  \\param numberOfElements Total number of elements in \\e ioVector.\n  \\param erroneousVectorIndex (out) A pointer to an index, stored in the caller's address\n  space, of the first iovector element that makes the invocation fail. If the index is set to\n  NULL or if the invocation succeeds, the field remains unchanged.\n  Updated if the clCkptCheckpointWrite() call fails.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER  When the parameters passed are NULL pointers.\n  \\retval CL_ERR_NOT_INITIALIZED If the checkpoint server is not completely initialized.\n  \\retval CL_ERR_NO_MEMORY On memory allocation failure.\n\n  \\par Description:\n  This function writes data from the memory regions specified by \\e ioVector into a checkpoint:\n  \\arg If this checkpoint is created with the \\c CL_CKPT_WR_ALL_REPLICAS\n  property, all of the checkpoint replicas gets updated when the invocation\n  returns. If the invocation does not complete or returns with an error, nothing\n  is written at all.\n  \\arg If the checkpoint is created with the\n  \\c CL_CKPT_WR_ACTIVE_REPLICA property, the active checkpoint replica\n  gets updated when the invocation returns. Other checkpoint replicas are\n  updated asynchronously. If the invocation does not complete or returns with\n  an error, nothing is written.\n  \\arg If the checkpoint is created with the\n  \\c CL_CKPT_WR_ACTIVE_REPLICA_WEAK property, the active checkpoint\n  replica gets updated when the invocation returns. Other checkpoint replicas\n  are updated asynchronously. If the invocation returns with an error, nothing\n  is written at all. However, if the invocation does not complete, the\n  operation may be partially completed and some sections may be corrupted in\n  the active checkpoint replica.\n  \\par\n  In a single invocation, several sections and several portions of sections can be\n  updated simultaneously. The elements of the \\e ioVectors are written in order from\n  \\e ioVector[0] to \\e ioVector [numberOfElements - 1]. As a result of this invocation, some\n  sections may grow.\n\n  \\par Library File:\n  ClCkpt\n\n  \\sa\n  clCkptSectionCreate(),\n  clCkptSectionDelete(),\n  clCkptSectionExpirationTimeSet(),\n  clCkptSectionIterationInitialize(),\n  clCkptSectionIterationNext(),\n  clCkptSectionIterationFinalize(),\n  clCkptSectionOverwrite()\n"]
    pub fn clCkptCheckpointWrite(
        checkpointHandle: ClCkptHdlT,
        ioVector: *const ClCkptIOVectorElementT,
        numberOfElements: ClUint32T,
        erroneousVectorIndex: *mut ClUint32T,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief  Writes a single section in a given checkpoint.\n\n  \\par Header File:\n  clCkptApi.h\n\n  \\param checkpointHandle The handle that designates the checkpoint that is written to.\n  The handle \\e checkpointHandle is obtained by invoking either\n  clCkptCheckpointOpen() or clCkptCheckpointOpenAsync() functions.\n  \\param sectionId A pointer to an identifier for the section that is to be overwritten.\n   If this pointer points to \\c CL_CKPT_DEFAULT_SECTION_ID, the default section is updated.\n  \\param dataBuffer Pointer to the buffer from where the data is being copied.\n  \\param dataSize The size in bytes of the data to be written, which becomes\n   the new size for this section.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER  When the parameters \\e sectionId and \\e dataBuffer\n  passed are NULL pointers.\n  \\retval CL_ERR_NOT_INITIALIZED If the checkpoint server is not completely initialized.\n  \\retval CL_ERR_NO_MEMORY On memory allocation failure.\n  \\retval CL_ERR_TRY_AGAIN System is in a transitory unstable state, please try later.\n\n  \\par Description:\n  This function is used to write a single section in a given checkpoint.\n  This function is similar to clCkptCheckpointWrite() except that it overwrites only a\n  single section. As a result of this invocation, the previous data and size of the section\n  will change. This function may be invoked, even if there was no prior invocation of\n  clCkptCheckpointWrite().\n\n  \\par Library File:\n  ClCkpt\n\n  \\sa\n  clCkptSectionCreate(),\n  clCkptSectionDelete(),\n  clCkptSectionExpirationTimeSet(),\n  clCkptSectionIterationInitialize(),\n  clCkptSectionIterationNext(),\n  clCkptSectionIterationFinalize(),\n  clCkptCheckpointWrite()\n"]
    pub fn clCkptSectionOverwrite(
        checkpointHandle: ClCkptHdlT,
        sectionId: *const ClCkptSectionIdT,
        dataBuffer: *const ::std::os::raw::c_void,
        dataSize: ClSizeT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Reads multiple sections at a time.\n\n  \\par Header File:\n  clCkptApi.h\n\n  \\param checkpointHandle The handle to the checkpoint that is to be read. The handle\n  \\e checkpointHandle obtained by invoking either\n  clCkptCheckpointOpen() or clCkptCheckpointOpenCallback() function.\n\n  \\param ioVector Pointer to an IO Vector containing the section IDs and the data to be written.\n\n  \\param numberOfElements  Total number of elements in \\e ioVector.\n  Each element is of the type\n  ClCkptIOVectorElementT, and containing the following fields:\n  \\arg sectionId: The identifier of the section to be read from.\n  \\arg dataBuffer: (in/out)  A pointer to a buffer containing the data to be read to. If\n  \\e dataBuffer is NULL, the value of \\e datasize provided by the invoker is ignored\n  and the buffer is provided by the Checkpoint Service library. The buffer must\n  be deallocated by the invoker.\n  \\arg dataSize: Size of the data to be read to the buffer designated by\n  \\e dataBuffer. The size is at most \\e maxSectionSize, as specified in the creation\n  attributes of the checkpoint.\n  \\arg dataOffset: Offset in the section that marks the start of the data that is to\n  be read.\n  \\arg readSize: (out) Used by clCkptCheckpointRead() to record the number of\n  bytes of data that have been read; otherwise, this field is not used.\n\n  \\param erroneousVectorIndex (out) Pointer to the index for errors in \\e ioVector.\n  This is an index in the caller's address space, of\n  the first vector element that causes the invocation to fail. If the invocation succeeds,\n  then \\e erroneousVectorIndex is \\c NULL and should be ignored.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER  When the parameters passed are NULL pointers.\n  \\retval CL_ERR_NOT_INITIALIZED If the checkpoint server is not completely initialized.\n  \\retval CL_ERR_NO_MEMORY On memory allocation failure.\n  \\retval CL_ERR_TRY_AGAIN System is in a transitory unstable state, please try later.\n\n  \\par Description:\n  This function is used to read multiple sections at a time. It can be used to\n  read a single section.\n\n  \\par Library File:\n  ClCkpt\n"]
    pub fn clCkptCheckpointRead(
        checkpointHandle: ClCkptHdlT,
        ioVector: *mut ClCkptIOVectorElementT,
        numberOfElements: ClUint32T,
        erroneousVectorIndex: *mut ClUint32T,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Synchronizes the replicas of a checkpoint.\n\n  \\par Header File:\n  clCkptApi.h\n\n  \\param checkpointHandle Checkpoint handle returned as part of clCkptCheckpointOpen.\n  \\param  timeout Time-out to execute the operation.[It is not supported currently]\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_TRY_AGAIN System is in a transitory unstable state, please try later.\n\n  \\par Description:\n  This function is used to synchronize the replicas of a checkpoint.\n\n  \\par Library File:\n  ClCkpt\n\n  \\sa clCkptCheckpointSynchronizeAsync()\n"]
    pub fn clCkptCheckpointSynchronize(ckeckpointHandle: ClCkptHdlT, timeout: ClTimeT) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Synchronizes the replicas of a Checkpoint asynchronously.\n\n  \\par Header File:\n  clCkptApi.h\n\n  \\param checkpointHandle Checkpoint handle returned as part of clCkptCheckpointOpen().\n  \\param invocation Identifies the call when the callback is called.\n\n  \\retval CL_OK The API executed successfully.\n\n  \\par Description:\n  This function is used to synchronize the replicas of a Checkpoint asynchronously.\n\n  \\par Library File:\n  ClCkpt\n\n  \\sa clCkptCheckpointSynchronize()\n"]
    pub fn clCkptCheckpointSynchronizeAsync(
        checkpointHandle: ClCkptHdlT,
        invocation: ClInvocationT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Registers a callback function to be called to notify change in the checkpoint data.\n\n  \\par Header File:\n  clCkptApi.h\n\n  \\param checkpointHandle Checkpoint handle returned as part of clCkptCheckpointOpen().\n  \\param\n  \\param invocation Identifies the call when the callback is called.\n\n  \\retval CL_OK The API executed successfully.\n\n  \\par Description:\n  This function is used to register a callback function that is called.\n  whenever the specified checkpoint data is updated.\n\n  \\par Library File:\n  ClCkpt\n"]
    pub fn clCkptImmediateConsumptionRegister(
        checkpointHandle: ClCkptHdlT,
        callback: ClCkptNotificationCallbackT,
        pCookie: ClPtrT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief  Helps detect pending callbacks.\n\n  \\par Header File:\n  clCkptApi.h\n\n  \\param ckptHandle The handle, obtained through the clCkptInitialize()\n   function, designating this particular initialization of the Ckpt Service.\n\n  \\param pSelectionObject (out) A pointer to the operating system handle that\n  the invoking EO can use to detect pending callbacks.\n\n  \\retval CL_OK The function completed successfully.\n  \\retval CL_ERR_NOT_INITIALIZED On initialization failure.\n  \\retval CL_ERR_INVALID_HANDLE On passing an invalid handle.\n  \\retval CL_ERR_INVALID_PARAMETER On passing an invalid parameter.\n\n  \\par Description:\n  This function returns the operating system handle, \\e pSelectionObject,\n  associated with the handle \\e ckptHandle. The invoking EO can use\n  this handle to detect pending callbacks, instead of repeatedly\n  invoking clCkptDispatch() for this purpose.\n  \\par\n  The \\e pSelectionObject returned by this function, is a file descriptor\n  that can be used with poll() or select() systems call detect incoming\n  callbacks.\n  \\par\n  The \\e selectionObject returned by this function is valid until\n  clCkptFinalize() is invoked on the same handle \\e ckptHandle.\n\n  \\par Library File:\n   ClCkpt\n\n  \\sa clCkptDispatch()\n"]
    pub fn clCkptSelectionObjectGet(
        ckptHandle: ClCkptSvcHdlT,
        selectionObject: *mut ClSelectionObjectT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Invokes the pending callback in context of the EO.\n\n  \\par Header File:\n  clCkptApi.h\n\n  \\param ckptHandle The handle, obtained through the clCkptInitialize()\n   function, designating this particular initialization of the Ckpt Service.\n\n  \\param dispatchFlags Flags that specify the callback execution behavior\n  clCkptDispatch() function, which have the values \\c CL_DISPATCH_ONE,\n  \\c CL_DISPATCH_ALL or \\c CL_DISPATCH_BLOCKING, as defined in clCommon.h.\n\n  \\retval CL_OK The function completed successfully.\n  \\retval CL_ERR_NOT_INITIALIZED On initialization failure.\n  \\retval CL_ERR_INVALID_HANDLE On passing an invalid handle.\n  \\retval CL_ERR_INVALID_PARAMETER On passing an invalid parameter.\n\n  \\par Description:\n  This function invokes, in the context of the calling EO, pending callbacks for\n  handle \\e ckptHandle in a way that is specified by the \\e dispatchFlags\n  parameter.\n\n  \\par Library File:\n   ClCkpt\n\n  \\sa clCkptSelectionObjectGet()\n"]
    pub fn clCkptDispatch(ckptHandle: ClCkptSvcHdlT, dispatchFlags: ClDispatchFlagsT) -> ClRcT;
}
