pub use crate::clBindings::clCommon::*;
pub use crate::clBindings::clCkptApi::*;
pub use crate::clBindings::clCntApi::*;
pub use crate::clBindings::clOsalApi::*;
pub use crate::clBindings::clEoApi::*;
pub use crate::clBindings::clDifferenceVector::*;
/* automatically generated by rust-bindgen 0.66.1 */

#[doc = " Serialize Signature."]
pub type ClCkptSerializeT = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ClUint32T,
        arg2: *mut ClAddrT,
        arg3: *mut ClUint32T,
        arg4: ClPtrT,
    ) -> ClRcT,
>;
#[doc = "  De-serialize Signature."]
pub type ClCkptDeserializeT = ::std::option::Option<
    unsafe extern "C" fn(arg1: ClUint32T, arg2: ClAddrT, arg3: ClUint32T, arg4: ClPtrT) -> ClRcT,
>;
#[repr(C)]
pub struct ClCkptDataSetCallback {
    pub version: ClVersionT,
    pub serialiser: ClCkptSerializeT,
    pub deSerialiser: ClCkptDeserializeT,
}
#[test]
fn bindgen_test_layout_ClCkptDataSetCallback() {
    const UNINIT: ::std::mem::MaybeUninit<ClCkptDataSetCallback> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClCkptDataSetCallback>(),
        24usize,
        concat!("Size of: ", stringify!(ClCkptDataSetCallback))
    );
    assert_eq!(
        ::std::mem::align_of::<ClCkptDataSetCallback>(),
        8usize,
        concat!("Alignment of ", stringify!(ClCkptDataSetCallback))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCkptDataSetCallback),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serialiser) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCkptDataSetCallback),
            "::",
            stringify!(serialiser)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deSerialiser) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCkptDataSetCallback),
            "::",
            stringify!(deSerialiser)
        )
    );
}
pub type ClCkptDataSetCallbackT = ClCkptDataSetCallback;
#[repr(C)]
pub struct ClCkptDifferenceIOVectorElement {
    #[doc = "  Identifier of the section."]
    pub sectionId: ClCkptSectionIdT,
    pub dataSize: ClSizeT,
    pub dataOffset: ClOffsetT,
    pub differenceVector: *mut ClDifferenceVectorT,
}
#[test]
fn bindgen_test_layout_ClCkptDifferenceIOVectorElement() {
    const UNINIT: ::std::mem::MaybeUninit<ClCkptDifferenceIOVectorElement> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClCkptDifferenceIOVectorElement>(),
        40usize,
        concat!("Size of: ", stringify!(ClCkptDifferenceIOVectorElement))
    );
    assert_eq!(
        ::std::mem::align_of::<ClCkptDifferenceIOVectorElement>(),
        8usize,
        concat!("Alignment of ", stringify!(ClCkptDifferenceIOVectorElement))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sectionId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCkptDifferenceIOVectorElement),
            "::",
            stringify!(sectionId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataSize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCkptDifferenceIOVectorElement),
            "::",
            stringify!(dataSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataOffset) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCkptDifferenceIOVectorElement),
            "::",
            stringify!(dataOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).differenceVector) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCkptDifferenceIOVectorElement),
            "::",
            stringify!(differenceVector)
        )
    );
}
pub type ClCkptDifferenceIOVectorElementT = ClCkptDifferenceIOVectorElement;
#[repr(C)]
pub struct ClCkptClientInfo {
    pub nodeAddress: ClIocNodeAddressT,
    pub portId: ClIocPortT,
}
#[test]
fn bindgen_test_layout_ClCkptClientInfo() {
    const UNINIT: ::std::mem::MaybeUninit<ClCkptClientInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClCkptClientInfo>(),
        8usize,
        concat!("Size of: ", stringify!(ClCkptClientInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<ClCkptClientInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(ClCkptClientInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nodeAddress) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCkptClientInfo),
            "::",
            stringify!(nodeAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).portId) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCkptClientInfo),
            "::",
            stringify!(portId)
        )
    );
}
pub type ClCkptClientInfoT = ClCkptClientInfo;
#[repr(C)]
pub struct ClCkptClientInfoList {
    pub numEntries: ClUint32T,
    pub pClientInfo: *mut ClCkptClientInfoT,
}
#[test]
fn bindgen_test_layout_ClCkptClientInfoList() {
    const UNINIT: ::std::mem::MaybeUninit<ClCkptClientInfoList> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ClCkptClientInfoList>(),
        16usize,
        concat!("Size of: ", stringify!(ClCkptClientInfoList))
    );
    assert_eq!(
        ::std::mem::align_of::<ClCkptClientInfoList>(),
        8usize,
        concat!("Alignment of ", stringify!(ClCkptClientInfoList))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).numEntries) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCkptClientInfoList),
            "::",
            stringify!(numEntries)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pClientInfo) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ClCkptClientInfoList),
            "::",
            stringify!(pClientInfo)
        )
    );
}
pub type ClCkptClientInfoListT = ClCkptClientInfoList;
extern "C" {
    #[doc = "  \\brief Initializes the client.\n\n  \\par Header File:\n  clCkptExtApi.h\n\n  \\param pCkptHdl (in/out) Handle to the client. This handle designates this particular\n  initialization of the service.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_NULL_POINTER When the parameter \\e pCkptHdl passed is a NULL pointer.\n  \\retval CL_ERR_NO_MEMORY On memory allocation failure.\n\n  \\par Description:\n  This function is used to initialize the client and allocates resources to it. The function\n  returns a handle that associates this particular initialization of the Checkpoint library.\n  This handle must be passed as the first input parameter for all invocations\n  of functions related to this library.\n\n  \\par Library File:\n  clCkpt\n\n  \\sa clCkptLibraryFinalize()\n"]
    pub fn clCkptLibraryInitialize(pCkptHdl: *mut ClCkptSvcHdlT) -> ClRcT;
}
extern "C" {
    pub fn clCkptLibraryInitializeDB(pCkptHdl: *mut ClCkptSvcHdlT, dbName: *const ClCharT)
        -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief  Destroys the client.\n\n  \\par Header File:\n  clCkptExtApi.h\n\n  \\param ckptHdl Handle to the client obtained from the clCkptLibraryInitialize()\n  function, designating this particular initialization of the Checkpoint library.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_INVALID_HANDLE On passing an invalid handle.\n\n  \\par Description:\n  This function is used to close the association with checkpoint service client.\n  It must be invoked when the services are no longer required.\n  This invocation frees all allocated resources.\n\n  \\par Library File:\n  clCkpt\n\n  \\sa clCkptLibraryInitialize()\n"]
    pub fn clCkptLibraryFinalize(ckptHdl: ClCkptSvcHdlT) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Creates the checkpoint.\n\n  \\par Header File:\n  clCkptExtApi.h\n\n  \\param ckptHdl Handle to the client obtained from the clCkptLibraryInitialize()\n  function, designating this particular initialization of the Checkpoint library.\n  \\param pCkptName Name of the Checkpoint.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_INVALID_HANDLE On passing an invalid handle.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n  \\retval CL_ERR_NO_MEMORY On memory allocation failure.\n\n  \\par Description:\n  This function is used to create the checkpoint. This function must be invoked before any\n  further operations can be done with the checkpoint.\n\n  \\par Library File:\n  clCkpt\n\n  \\sa clCkptLibraryCkptDelete\n"]
    pub fn clCkptLibraryCkptCreate(ckptHdl: ClCkptSvcHdlT, pCkptName: *mut ClNameT) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Deletes the checkpoint.\n\n  \\par Header File:\n  clCkptExtApi.h\n\n  \\param ckptHdl Handle to the client obtained from the clCkptLibraryInitialize()\n  function, designating this particular initialization of the Checkpoint library.\n  \\param pCkptName Name of the Checkpoint to be deleted.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_INVALID_HANDLE On passing an invalid handle.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n\n  \\par Description:\n  This function is used to delete the checkpoint. This must be invoked when the checkpoint\n  services are no longer required. This invocation frees all resources associated with the checkpoint.\n\n  \\par Library File:\n  clCkpt\n\n  \\sa clCkptLibraryCkptCreate()\n"]
    pub fn clCkptLibraryCkptDelete(ckptHdl: ClCkptSvcHdlT, pCkptName: *mut ClNameT) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Creates a data set.\n\n  \\par Header File:\n  clCkptExtApi.h\n\n  \\param ckptHdl Handle to the client obtained from the clCkptLibraryInitialize()\n  function, designating this particular initialization of the Checkpoint library.\n  \\param pCkptName Name of the Checkpoint.\n  \\param dsId A unique identifier for identifying the data set.\n  \\param grpId An optional group Id to group different data sets together. [Currently not used]\n  \\param order When all the members of group are checkpointed the order in which this\n  particular data set is checkpointed. [Currently not used]\n  \\param dsSerialiser Serialiser or encoder for the data.\n  \\param dsDeserialiser Deserialiser/decoder for the data.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_INVALID_HANDLE On passing an invalid handle.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n  \\retval CL_ERR_INVALID_PARAMETER On passing an invalid parameter.\n  \\retval CL_ERR_NO_MEMORY On memory allocation failure.\n\n  \\par Description:\n  This function is used to create a data set and allocate resources to it.\n  This function should be invoked before performing any further operations\n  on the dataset. The dataset information can then be read, or written into\n  the database.\n\n  \\par Library File:\n  clCkpt\n\n  \\sa\n  clCkptLibraryCkptDataSetDelete(),\n  clCkptLibraryCkptDataSetWrite(),\n  clCkptLibraryCkptDataSetRead()\n"]
    pub fn clCkptLibraryCkptDataSetCreate(
        ckptHdl: ClCkptSvcHdlT,
        pCkptName: *mut ClNameT,
        dsId: ClUint32T,
        grpId: ClUint32T,
        order: ClUint32T,
        dsSerialiser: ClCkptSerializeT,
        dsDeserialiser: ClCkptDeserializeT,
    ) -> ClRcT;
}
extern "C" {
    pub fn clCkptLibraryCkptDataSetVersionCreate(
        ckptHdl: ClCkptSvcHdlT,
        pCkptName: *mut ClNameT,
        dsId: ClUint32T,
        grpId: ClUint32T,
        order: ClUint32T,
        pTable: *mut ClCkptDataSetCallbackT,
        numTableEntries: ClUint32T,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Deletes the dataset from the checkpoint.\n\n  \\par Header File:\n  clCkptExtApi.h\n\n  \\param ckptHdl Handle to the client obtained from the clCkptLibraryInitialize()\n  function, designating this particular initialization of the Checkpoint library.\n  \\param pCkptName Name of the Checkpoint.\n  \\param dsId Identifier of the dataset to be deleted.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_INVALID_HANDLE On passing an invalid handle.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n  \\retval CL_ERR_INVALID_PARAMETER On passing an invalid parameter.\n  \\retval CL_ERR_NOT_EXIST The specified argument is not exist.\n\n  \\par Description:\n  This function is used to delete the dataset from the checkpoint.\n  Before this function is invoked, the dataset must have been created\n  using the clCkptLibraryCkptDataSetCreate() function.\n\n  \\par Library File:\n  clCkpt\n\n  \\sa\n  clCkptLibraryCkptDataSetCreate(),\n  clCkptLibraryCkptDataSetWrite(),\n  clCkptLibraryCkptDataSetRead()\n"]
    pub fn clCkptLibraryCkptDataSetDelete(
        ckptHdl: ClCkptSvcHdlT,
        pCkptName: *mut ClNameT,
        dsId: ClUint32T,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Writes the dataset information into the database.\n\n  \\par Header File:\n  clCkptExtApi.h\n\n  \\param ckptHdl Handle to the client obtained from the clCkptLibraryInitialize()\n  function, designating this particular initialization of the Checkpoint library.\n  \\param pCkptName Name of the Checkpoint.\n  \\param dsId Identifier of the dataset to be written.\n  \\param cookie User-data which will be opaquely passed to the serializer.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_INVALID_HANDLE On passing an invalid handle.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n  \\retval CL_ERR_NOT_EXIST The specified argument is not exist.\n\n  \\par Description:\n  This function is used to write the dataset information into the database.\n\n  \\par Library File:\n  clCkpt\n\n  \\sa\n  clCkptLibraryCkptDataSetCreate(),\n  clCkptLibraryCkptDataSetDelete(),\n  clCkptLibraryCkptDataSetRead()\n"]
    pub fn clCkptLibraryCkptDataSetWrite(
        ckptHdl: ClCkptSvcHdlT,
        pCkptName: *mut ClNameT,
        dsId: ClUint32T,
        cookie: ClPtrT,
    ) -> ClRcT;
}
extern "C" {
    pub fn clCkptLibraryCkptDataSetVersionWrite(
        ckptHdl: ClCkptSvcHdlT,
        pCkptName: *mut ClNameT,
        dsId: ClUint32T,
        cookie: ClPtrT,
        pVersion: *mut ClVersionT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Reads the dataset information into the database.\n\n  \\par Header File:\n  clCkptExtApi.h\n\n  \\param ckptHdl Handle to the client obtained from the clCkptLibraryInitialize()\n  function, designating this particular initialization of the Checkpoint library.\n  \\param pCkptName Name of the Checkpoint.\n  \\param dsId Identifier of the dataset to be written.\n  \\param cookie User-data which will be opaquely passed to the serializer.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_INVALID_HANDLE On passing an invalid handle.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n  \\retval CL_ERR_NOT_EXIST The specified  argument does not exist.\n\n  \\par Description:\n  This function is used to read the Dataset information from database.\n\n  \\par Library File:\n  clCkpt\n\n  \\sa\n  clCkptLibraryCkptDataSetCreate(),\n  clCkptLibraryCkptDataSetDelete(),\n  clCkptLibraryCkptDataSetRead()\n"]
    pub fn clCkptLibraryCkptDataSetRead(
        ckptHdl: ClCkptSvcHdlT,
        pCkptName: *mut ClNameT,
        dsId: ClUint32T,
        cookie: ClPtrT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Checks the existence of a checkpoint.\n\n  \\par Header File:\n  clCkptExtApi.h\n\n  \\param ckptHdl Handle to the client obtained from the clCkptLibraryInitialize()\n  function, designating this particular initialization of the Checkpoint library.\n  \\param pCkptName Name of the Checkpoint.\n  \\param pRetVal Return value to the user, returns \\c CL_TRUE if it exists.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_INVALID_HANDLE On passing an invalid handle.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n\n  \\par Description:\n  This function is used to check if the given checkpoint exists or not.\n\n  \\par Library File:\n  clCkpt\n\n  \\sa clCkptLibraryDoesDatasetExist()\n"]
    pub fn clCkptLibraryDoesCkptExist(
        ckptHdl: ClCkptSvcHdlT,
        pCkptName: *mut ClNameT,
        pRetVal: *mut ClBoolT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Checks the existence of a Dataset in a given checkpoint.\n\n  \\par Header File:\n  clCkptExtApi.h\n\n  \\param ckptHdl Handle to the client obtained from the clCkptLibraryInitialize()\n  function, designating this particular initialization of the Checkpoint library.\n  \\param pCkptName Name of the Checkpoint.\n  \\param dsId Identifier of the dataset.\n  \\param pRetVal Return value to the user, returns CL_TRUE, if it exists.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_INVALID_HANDLE On passing an invalid handle.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n\n  \\par Description:\n  This function is used to check whether the given Dataset exists.\n\n  \\par Library File:\n  clCkpt\n\n  \\sa clCkptLibraryDoesCkptExist()\n"]
    pub fn clCkptLibraryDoesDatasetExist(
        ckptHdl: ClCkptSvcHdlT,
        pCkptName: *mut ClNameT,
        dsId: ClUint32T,
        pRetVal: *mut ClBoolT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Creates the element of the Dataset.\n\n  \\par Header File:\n  clCkptExtApi.h\n\n  \\param ckptHdl Handle to the client obtained from the clCkptLibraryInitialize()\n  function, designating this particular initialization of the Checkpoint library.\n  \\param pCkptName Name of the Checkpoint.\n  \\param dsId Identifier of the dataset to be written.\n  \\param elemSerialiser  Encoder of the element Data\n  \\param elemDeserialiser Decoder of the element Data.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_INVALID_HANDLE On passing an invalid handle.\n  \\retval CL_ERR_NULL_POINTER On passing a NULL pointer.\n  \\retval CL_ERR_NOT_EXIST The specified argument is not exist.\n\n  \\par Description:\n  This function is used to create an element of the dataset. It must\n  be invoked before any element of the dataset can be written.\n\n  \\par Library File:\n  clCkpt\n\n  \\sa clCkptLibraryCkptElementWrite()\n"]
    pub fn clCkptLibraryCkptElementCreate(
        ckptHdl: ClCkptSvcHdlT,
        pCkptName: *mut ClNameT,
        dsId: ClUint32T,
        elemSerialiser: ClCkptSerializeT,
        elemDeserialiser: ClCkptDeserializeT,
    ) -> ClRcT;
}
extern "C" {
    pub fn clCkptLibraryCkptElementVersionCreate(
        ckptHdl: ClCkptSvcHdlT,
        pCkptName: *mut ClNameT,
        dsId: ClUint32T,
        pTable: *mut ClCkptDataSetCallbackT,
        numTableEntries: ClUint32T,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Writes the Element information into the database.\n\n  \\par Header File:\n  clCkptExtApi.h\n\n  \\param ckptHdl Handle to the client obtained from the clCkptLibraryInitialize()\n  function, designating this particular initialization of the Checkpoint library.\n  \\param pCkptName Name of the Checkpoint.\n  \\param dsId Identifier of the dataset to be written.\n  \\param elemName Identifier of the element.\n  \\param elemLen Length of the \\e elemId.\n  \\param cookie User data. This is opaquely passed to the serializer.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_INVALID_HANDLE On passing an invalid handle.\n  \\retval CL_ERR_NULL_POINTER On passing \\e pCkptName as a NULL pointer.\n  \\retval CL_ERR_INVALID_PARAMETER On passing an invalid parameter.\n  \\retval CL_ERR_NOT_EXIST The specified argument does not exist.\n\n  \\par Description:\n  This function is used to write the Element information into the database.\n  Before this function is invoked, the element must be created\n  using the clCkptLibraryCkptElementCreate() function.\n\n  \\par Library File:\n  clCkpt\n\n  \\sa clCkptLibraryCkptElementCreate()\n"]
    pub fn clCkptLibraryCkptElementWrite(
        ckptHdl: ClCkptSvcHdlT,
        pCkptName: *mut ClNameT,
        dsId: ClUint32T,
        elemId: ClPtrT,
        elemLen: ClUint32T,
        cookie: ClPtrT,
    ) -> ClRcT;
}
extern "C" {
    pub fn clCkptLibraryCkptElementVersionWrite(
        ckptHdl: ClCkptSvcHdlT,
        pCkptName: *mut ClNameT,
        dsId: ClUint32T,
        elemId: ClPtrT,
        elemLen: ClUint32T,
        cookie: ClPtrT,
        pVersion: *mut ClVersionT,
    ) -> ClRcT;
}
extern "C" {
    #[doc = "  \\brief Writes the Element information into the database.\n\n  \\par Header File:\n  clCkptExtApi.h\n\n  \\param ckptHdl Handle to the client obtained from the clCkptLibraryInitialize()\n  function, designating this particular initialization of the Checkpoint library.\n  \\param pCkptName Name of the Checkpoint.\n  \\param dsId Identifier of the dataset to be written.\n  \\param elemId Identifier of the element.\n  \\param elemLen Length of the \\e elemId.\n\n  \\retval CL_OK The API executed successfully.\n  \\retval CL_ERR_INVALID_HANDLE On passing an invalid handle.\n  \\retval CL_ERR_NULL_POINTER On passing \\e pCkptName as a NULL pointer.\n  \\retval CL_ERR_INVALID_PARAMETER On passing an invalid parameter.\n  \\retval CL_ERR_NOT_EXIST The specified argument does not exist.\n\n  \\par Description:\n  This function is used to delete element data which was written already by\n  API clCkptLibraryCkptElementDelete.\n  Before this function is invoked, the element must be created and key\n  should exist.\n\n  \\par Library File:\n  clCkpt\n\n  \\sa clCkptLibraryCkptElementCreate()\n"]
    pub fn clCkptLibraryCkptElementDelete(
        ckptHdl: ClCkptSvcHdlT,
        pCkptName: *mut ClNameT,
        dsId: ClUint32T,
        elemId: ClPtrT,
        elemLen: ClUint32T,
    ) -> ClRcT;
}
extern "C" {
    pub fn clCkptReplicaChangeRegister(
        pCkptRelicaChangeCallback: ::std::option::Option<
            unsafe extern "C" fn(
                pCkptName: *const ClNameT,
                replicaAddr: ClIocNodeAddressT,
            ) -> ClRcT,
        >,
    ) -> ClRcT;
}
extern "C" {
    pub fn clCkptReplicaChangeDeregister() -> ClRcT;
}
extern "C" {
    pub fn clCkptSectionOverwriteVector(
        ckptHdl: ClCkptHdlT,
        pSectionId: *const ClCkptSectionIdT,
        dataSize: ClSizeT,
        differenceVector: *mut ClDifferenceVectorT,
    ) -> ClRcT;
}
extern "C" {
    pub fn clCkptCheckpointReadSections(
        ckptHdl: ClCkptHdlT,
        ppIOVecs: *mut *mut ClCkptIOVectorElementT,
        pNumVecs: *mut ClUint32T,
    ) -> ClRcT;
}
extern "C" {
    pub fn clCkptIOVectorFree(pIOVec: *mut ClCkptIOVectorElementT, numVecs: ClUint32T) -> ClRcT;
}
